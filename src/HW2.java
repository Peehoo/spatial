import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.EventQueue;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Polygon;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.ButtonGroup;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JLabel;
import javax.swing.ImageIcon;
import javax.swing.LayoutStyle.ComponentPlacement;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.io.WKBReader;

import javax.swing.JCheckBox;
import javax.swing.JRadioButton;
import javax.swing.JButton;

import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.awt.Font;

import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.UIManager;

public class HW2 extends JFrame {
	public static AnnouncementSystemJpanel label;
	public static JTextArea queryTextArea;
	Connection connection;
	JCheckBox chckbxBuilding = new JCheckBox("Building");
	JCheckBox chckbxAs = new JCheckBox("AS");
	JLabel lblActiveFeatureType = new JLabel("Active Feature Type");
	JCheckBox chckbxStudents = new JCheckBox("Students");
	JRadioButton rdbtnWholeRegion = new JRadioButton("Whole Region");
	JRadioButton rdbtnPointQuery = new JRadioButton("Point Query");
	JRadioButton rdbtnRangeQuery = new JRadioButton("Range Query");
	JRadioButton rdbtnSurroundingStudent = new JRadioButton("Surrounding Student");
	JRadioButton rdbtnEmergencyQuery = new JRadioButton("Emergency Query");
	JButton submitButton = new JButton("Submit      Query");
	boolean submitClicked = false;
	private JPanel contentPane;
	private AnnouncementSystemMouseListener announcementMouseListner;
	private static final int POINT_QUERY_RADIUS = 50;
	private static final int POINT_SQUARE_WIDTH = 5;
	private static final int STUDENT_SQUARE_WIDTH = 10;
	private static final int ANNOUNCEMENT_SQUARE_WIDTH = 15;
	private static String queriesExecuted = "";
	static int queryCounter = 0;
	public static JTextField mousePositionField = new JTextField();

	/**
	 * Gets the database connection
	 * @return
	 */
	private static Connection getConnection() {
		java.sql.Connection connection = null;
		try {
			Class.forName("com.mysql.jdbc.Driver");
			connection = DriverManager
					.getConnection("jdbc:mysql://localhost/geometric?"
							+ "user=root&password=");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return connection;
	}

	/**
	 * Executes a given select query and returns a ResultSet
	 * @param query
	 * @param connection
	 * @throws SQLException
	 */
	private static ResultSet executeSelectQuery(String query,
			Connection connection) throws SQLException {
		java.sql.Statement stmt = connection.createStatement();
		queriesExecuted = queriesExecuted + "Query " + ++queryCounter + ". "
				+ query + "\n";
		queryTextArea.setText(queriesExecuted);
		return stmt.executeQuery(query);
	}


	/**
	 * Launch the application.
	 * @throws SQLException
	 */
	public static void main(String[] args) throws SQLException {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					HW2 frame = new HW2();
					frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

		});
	}

	/**
	 * Create the frame. Automatically generated by Windows Builder. Some modifications were made to the generated code.
	 */
	public HW2() {
		this.setTitle("Peehoo Dewan - 5737220076");
		mousePositionField.setEditable(false);
		mousePositionField.setBackground(UIManager
				.getColor("Button.background"));
		mousePositionField.setColumns(10);
		connection = getConnection();
		announcementMouseListner = new AnnouncementSystemMouseListener();
		label = new AnnouncementSystemJpanel();
		label.addMouseListener(announcementMouseListner);
		label.addMouseMotionListener(announcementMouseListner);

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setBounds(0, 0, 1200, 700);
		contentPane = new JPanel();
		contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
		setContentPane(contentPane);

		label.setIcon(new ImageIcon("map.jpg"));

		JPanel panel = new JPanel();

		ButtonGroup buttonHandler = new ButtonGroup();
		buttonHandler.add(rdbtnEmergencyQuery);
		buttonHandler.add(rdbtnPointQuery);
		buttonHandler.add(rdbtnRangeQuery);
		buttonHandler.add(rdbtnSurroundingStudent);
		buttonHandler.add(rdbtnWholeRegion);
		submitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				submitClicked = true;
				label.repaint();
			}
		});

		queryTextArea = new JTextArea();
		queryTextArea.setText("The submitted queries are:");
		JScrollPane scrollPane = new JScrollPane(queryTextArea);
		GroupLayout gl_contentPane = new GroupLayout(contentPane);
		gl_contentPane
				.setHorizontalGroup(gl_contentPane
						.createParallelGroup(Alignment.LEADING)
						.addGroup(
								Alignment.TRAILING,
								gl_contentPane
										.createSequentialGroup()
										.addContainerGap(928, Short.MAX_VALUE)
										.addComponent(mousePositionField,
												GroupLayout.PREFERRED_SIZE,
												GroupLayout.DEFAULT_SIZE,
												GroupLayout.PREFERRED_SIZE)
										.addGap(128))
						.addGroup(
								gl_contentPane
										.createSequentialGroup()
										.addGroup(
												gl_contentPane
														.createParallelGroup(
																Alignment.TRAILING,
																false)
														.addComponent(
																scrollPane)
														.addGroup(
																Alignment.LEADING,
																gl_contentPane
																		.createSequentialGroup()
																		.addGap(1)
																		.addComponent(
																				label,
																				GroupLayout.PREFERRED_SIZE,
																				820,
																				GroupLayout.PREFERRED_SIZE)))
										.addGap(1)
										.addGroup(
												gl_contentPane
														.createParallelGroup(
																Alignment.LEADING)
														.addComponent(
																panel,
																GroupLayout.PREFERRED_SIZE,
																362,
																Short.MAX_VALUE)
														.addGroup(
																gl_contentPane
																		.createSequentialGroup()
																		.addGap(90)
																		.addComponent(
																				submitButton,
																				GroupLayout.PREFERRED_SIZE,
																				172,
																				GroupLayout.PREFERRED_SIZE)))
										.addContainerGap()));
		gl_contentPane
				.setVerticalGroup(gl_contentPane
						.createParallelGroup(Alignment.LEADING)
						.addGroup(
								gl_contentPane
										.createSequentialGroup()
										.addGap(1)
										.addGroup(
												gl_contentPane
														.createParallelGroup(
																Alignment.LEADING)
														.addGroup(
																gl_contentPane
																		.createSequentialGroup()
																		.addComponent(
																				label,
																				GroupLayout.PREFERRED_SIZE,
																				580,
																				GroupLayout.PREFERRED_SIZE)
																		.addGap(18)
																		.addComponent(
																				scrollPane,
																				GroupLayout.PREFERRED_SIZE,
																				45,
																				GroupLayout.PREFERRED_SIZE))
														.addGroup(
																gl_contentPane
																		.createSequentialGroup()
																		.addComponent(
																				panel,
																				GroupLayout.PREFERRED_SIZE,
																				497,
																				GroupLayout.PREFERRED_SIZE)
																		.addPreferredGap(
																				ComponentPlacement.RELATED,
																				39,
																				Short.MAX_VALUE)
																		.addComponent(
																				submitButton)
																		.addGap(40)
																		.addComponent(
																				mousePositionField,
																				GroupLayout.PREFERRED_SIZE,
																				GroupLayout.DEFAULT_SIZE,
																				GroupLayout.PREFERRED_SIZE)))
										.addContainerGap()));


		panel.setLayout(null);
		lblActiveFeatureType
				.setFont(new Font("Times New Roman", Font.BOLD, 20));
		lblActiveFeatureType.setBounds(8, 5, 233, 28);
		System.out
				.println(panel.getAlignmentX() + ", " + panel.getAlignmentY());

		panel.add(lblActiveFeatureType);
		chckbxAs.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		chckbxAs.setBounds(8, 45, 161, 23);

		panel.add(chckbxAs);
		chckbxBuilding.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		chckbxBuilding.setBounds(8, 73, 161, 23);

		chckbxBuilding.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {
			}
		});
		panel.add(chckbxBuilding);
		chckbxStudents.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		chckbxStudents.setBounds(211, 73, 105, 23);

		panel.add(chckbxStudents);

		JLabel lblQuery = new JLabel("Query");
		lblQuery.setFont(new Font("Times New Roman", Font.BOLD, 20));
		lblQuery.setBounds(8, 177, 161, 28);
		panel.add(lblQuery);
		rdbtnWholeRegion.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		rdbtnWholeRegion.setBounds(8, 236, 161, 23);
		rdbtnWholeRegion.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent arg0) {
				label.repaint();
			}
		});

		panel.add(rdbtnWholeRegion);
		rdbtnPointQuery.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		rdbtnPointQuery.setBounds(8, 264, 161, 23);
		rdbtnPointQuery.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				label.repaint();
				if (e.getStateChange() == 1)
					announcementMouseListner
							.setRadioButtonSelected(AnnouncementSystemMouseListener.POINT_QUERY_BUTTON);
				else {
					announcementMouseListner.setRadioButtonSelected(-1);
					announcementMouseListner.resetClick();
				}
			}
		});

		panel.add(rdbtnPointQuery);
		rdbtnRangeQuery.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		rdbtnRangeQuery.setBounds(8, 292, 161, 23);
		rdbtnRangeQuery.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				label.repaint();
				if (e.getStateChange() == 1)
					announcementMouseListner
							.setRadioButtonSelected(AnnouncementSystemMouseListener.RANGE_QUERY_BUTTON);
				else {
					announcementMouseListner.setRadioButtonSelected(-1);
					announcementMouseListner.resetClick();
					label.resetPolygon();
				}
			}
		});

		panel.add(rdbtnRangeQuery);
		rdbtnSurroundingStudent.setFont(new Font("Lucida Grande", Font.PLAIN,
				15));
		rdbtnSurroundingStudent.setBounds(8, 320, 186, 23);
		rdbtnSurroundingStudent.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				label.repaint();
				if (e.getStateChange() == 1)
					announcementMouseListner
							.setRadioButtonSelected(AnnouncementSystemMouseListener.SURROUNDING_QUERY_BUTTON);
				else {
					announcementMouseListner.setRadioButtonSelected(-1);
					announcementMouseListner.resetClick();
				}
			}
		});

		panel.add(rdbtnSurroundingStudent);
		rdbtnEmergencyQuery.setFont(new Font("Lucida Grande", Font.PLAIN, 15));
		rdbtnEmergencyQuery.setBounds(8, 348, 161, 23);
		rdbtnEmergencyQuery.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				label.repaint();
				if (e.getStateChange() == 1)
					announcementMouseListner
							.setRadioButtonSelected(AnnouncementSystemMouseListener.EMERGENCY_QUERY_BUTTON);
				else {
					announcementMouseListner.setRadioButtonSelected(-1);
					announcementMouseListner.resetClick();
				}
			}
		});

		panel.add(rdbtnEmergencyQuery);
		contentPane.setLayout(gl_contentPane);
	}

	/**
	 * This method returns a geometry object
	 * Taken from http://www.dev-garden.org/2011/11/27/loading-mysql-spatial-data-with-jdbc-and-jts-wkbreader/
	 * @param inputStream
	 * @return a geometry object
	 * @throws Exception
	 */
	private Geometry getGeometryFromInputStream(InputStream inputStream)
			throws Exception {

		Geometry dbGeometry = null;

		if (inputStream != null) {

			// convert the stream to a byte[] array
			// so it can be passed to the WKBReader
			byte[] buffer = new byte[255];

			int bytesRead = 0;
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			while ((bytesRead = inputStream.read(buffer)) != -1) {
				baos.write(buffer, 0, bytesRead);
			}

			byte[] geometryAsBytes = baos.toByteArray();

			if (geometryAsBytes.length < 5) {
				throw new Exception(
						"Invalid geometry inputStream - less than five bytes");
			}

			// first four bytes of the geometry are the SRID,
			// followed by the actual WKB. Determine the SRID
			// here
			byte[] sridBytes = new byte[4];
			System.arraycopy(geometryAsBytes, 0, sridBytes, 0, 4);
			boolean bigEndian = (geometryAsBytes[4] == 0x00);

			int srid = 0;
			if (bigEndian) {
				for (int i = 0; i < sridBytes.length; i++) {
					srid = (srid << 8) + (sridBytes[i] & 0xff);
				}
			} else {
				for (int i = 0; i < sridBytes.length; i++) {
					srid += (sridBytes[i] & 0xff) << (8 * i);
				}
			}

			// use the JTS WKBReader for WKB parsing
			WKBReader wkbReader = new WKBReader();

			// copy the byte array, removing the first four
			// SRID bytes
			byte[] wkb = new byte[geometryAsBytes.length - 4];
			System.arraycopy(geometryAsBytes, 4, wkb, 0, wkb.length);
			dbGeometry = wkbReader.read(wkb);
			dbGeometry.setSRID(srid);
		}
		return dbGeometry;
	}

	public class AnnouncementSystemJpanel extends JLabel {
		private ArrayList<Point> rangeQueryPolygon = new ArrayList<Point>();

		public void resetPolygon() {
			this.rangeQueryPolygon = new ArrayList<Point>();
		}

		/**
		 * This method is invoked whenever repaint method is called, i.e., 
		 * when the user clicks the submit query button or through the AnnouncementSystem
		 * mouse listener. The method executes appropriate queries based on the buttons 
		 * selected by a user
		 */
		public void paintComponent(Graphics g) {
			super.paintComponent(g);

			String selectAnnouncementsQuery = "select radius, as_loc from Announcements;";
			String selectStudentsQuery = "select student_loc from students;";
			String selectBuildingsQuery = "select coordinates from Buildings;";

			try {
				if (rdbtnPointQuery.isSelected()) {
					if (announcementMouseListner.getX() != -1) {
						drawClickedPoint(g);
						if (submitClicked) {
							submitClicked = false;
							if (chckbxAs.isSelected()) {
								drawASPointQuery(g);
							}
							if (chckbxStudents.isSelected()) {
								drawStudentPointQuery(g);
							}
							if (chckbxBuilding.isSelected()) {
								drawBuildingsPointQuery(g);
							}
						}
					}
				} else if (rdbtnRangeQuery.isSelected()) {
					handleRangeQuery(g);

				} else if (rdbtnWholeRegion.isSelected()) {
					if (submitClicked) {
						submitClicked = false;
						if (chckbxAs.isSelected()) {
							drawAnnouncementSystem(g, selectAnnouncementsQuery);
						}
						if (chckbxStudents.isSelected()) {
							drawStudents(g, selectStudentsQuery, Color.GREEN);
						}
						if (chckbxBuilding.isSelected()) {
							drawBuildings(g, selectBuildingsQuery);
						}
					}
				} else if (rdbtnSurroundingStudent.isSelected()) {
					handleSurroundingStudent(g);
				} else if (rdbtnEmergencyQuery.isSelected()) {
					handleEmergency(g);
				}

			} catch (SQLException e) {
				e.printStackTrace();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		/**
		 * Implements the Surrounding Student Query Usecase
		 * @param g
		 * @throws SQLException
		 * @throws Exception
		 */
		private void handleSurroundingStudent(Graphics g) throws SQLException,
				Exception {
			if (announcementMouseListner.getX() != -1) {
				int clickedPointX = announcementMouseListner.getX();
				int clickedPointY = announcementMouseListner.getY();
				drawPoint(g, clickedPointX,clickedPointY);
				String closestAnnouncementsLoc = "SELECT radius, as_loc FROM Announcements;";
				ResultSet rs = executeSelectQuery(closestAnnouncementsLoc,
						connection);

				com.vividsolutions.jts.geom.Point minPoint = null;
				double minDistance = Integer.MAX_VALUE;
				HashMap<com.vividsolutions.jts.geom.Point, Integer> points = new HashMap<com.vividsolutions.jts.geom.Point, Integer>();

				while (rs.next()) {

					int radius = rs.getInt("radius");
					InputStream inputStream = rs.getBinaryStream("as_loc");
					com.vividsolutions.jts.geom.Point p = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);

					com.vividsolutions.jts.geom.Point cPoint = new com.vividsolutions.jts.geom.Point(
							new Coordinate(clickedPointX, clickedPointY),
							p.getPrecisionModel(), p.getSRID());

					if (p.distance(cPoint) < minDistance) {
						minDistance = p.distance(cPoint);
						minPoint = p;
					}
					points.put(p, radius);
				}
				drawAnnouncementCircle(g, points.get(minPoint), minPoint,
						Color.RED);
				if (submitClicked) {
					submitClicked = false;
					String surroundingStudentsQuery = "select student_loc from students WHERE ST_Intersects( Buffer(POINT("
							+ minPoint.getX()
							+ ","
							+ minPoint.getY()
							+ "),"
							+ points.get(minPoint) + "), student_loc); ";
					drawStudents(g, surroundingStudentsQuery, Color.GREEN);
				}
			}
		}

		/**
		 * Implements the Emergency Query Usecase
		 * @param g
		 * @throws SQLException
		 * @throws Exception
		 */
		private void handleEmergency(Graphics g) throws SQLException, Exception {
			if (announcementMouseListner.getX() != -1) {
				Random r = new Random();
				int clickedPointX = announcementMouseListner.getX();
				int clickedPointY = announcementMouseListner.getY();
				drawPoint(g, clickedPointX,clickedPointY);

				String closestAnnouncementsLoc = "SELECT radius, as_loc FROM Announcements;";
				ResultSet rs = executeSelectQuery(closestAnnouncementsLoc,
						connection);

				com.vividsolutions.jts.geom.Point minPoint = null;
				double minDistance = Integer.MAX_VALUE;
				HashMap<com.vividsolutions.jts.geom.Point, Integer> points = new HashMap<com.vividsolutions.jts.geom.Point, Integer>();

				while (rs.next()) {

					int radius = rs.getInt("radius");
					InputStream inputStream = rs.getBinaryStream("as_loc");
					com.vividsolutions.jts.geom.Point p = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);

					com.vividsolutions.jts.geom.Point cPoint = new com.vividsolutions.jts.geom.Point(
							new Coordinate(clickedPointX, clickedPointY),
							p.getPrecisionModel(), p.getSRID());

					if (p.distance(cPoint) < minDistance) {
						minDistance = p.distance(cPoint);
						minPoint = p;
					}
					points.put(p, radius);
				}
				drawAnnouncementCircle(g, points.get(minPoint), minPoint,
						Color.RED);

				if (submitClicked) {
					submitClicked = false;
					String surroundingStudentsQuery = "select student_loc from students WHERE ST_Intersects( Buffer(POINT("
							+ minPoint.getX()
							+ ","
							+ minPoint.getY()
							+ "),"
							+ points.get(minPoint) + "), student_loc); ";
					points.remove(minPoint);
					rs = executeSelectQuery(surroundingStudentsQuery,
							connection);
					Map<com.vividsolutions.jts.geom.Point, Set<com.vividsolutions.jts.geom.Point>> asStudentMap = new HashMap<com.vividsolutions.jts.geom.Point, Set<com.vividsolutions.jts.geom.Point>>();
					for (com.vividsolutions.jts.geom.Point point : points
							.keySet()) {
						asStudentMap
								.put(point,
										new HashSet<com.vividsolutions.jts.geom.Point>());
					}
					while (rs.next()) {
						InputStream inputStream = rs
								.getBinaryStream("student_loc");
						com.vividsolutions.jts.geom.Point studentLoc = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);
						com.vividsolutions.jts.geom.Point asLoc = getNearestAS(
								studentLoc, points);
						if (asStudentMap.containsKey(asLoc)) {
							asStudentMap.get(asLoc).add(studentLoc);
						}

						for (Entry<com.vividsolutions.jts.geom.Point, Set<com.vividsolutions.jts.geom.Point>> entry : asStudentMap
								.entrySet()) {
							Color c = new Color(r.nextInt(255), r.nextInt(255),
									r.nextInt(255));
							drawAnnouncementCircle(g,
									points.get(entry.getKey()), entry.getKey(),
									c);

							for (com.vividsolutions.jts.geom.Point student : entry
									.getValue()) {
								g.setColor(c);
								int x = (int) student.getX();
								int y = (int) student.getY();
								g.drawRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
								g.fillRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
							}
						}
					}
				}
			}
		}

		/**
		 * Gets the nearest Announcement system (among the ones passed in asLocations) 
		 * to the given student
		 * @param studentLoc
		 * @param asLocations
		 * @return
		 */
		private com.vividsolutions.jts.geom.Point getNearestAS(
				com.vividsolutions.jts.geom.Point studentLoc,
				HashMap<com.vividsolutions.jts.geom.Point, Integer> asLocations) {

			com.vividsolutions.jts.geom.Point minPoint = null;
			double minDistance = Integer.MAX_VALUE;

			for (com.vividsolutions.jts.geom.Point as_loc : asLocations.keySet()) {
				if (as_loc.distance(studentLoc) < minDistance) {
					minDistance = as_loc.distance(studentLoc);
					minPoint = as_loc;
				}
			}
			return minPoint;
		}

		/**
		 * Implements the Range Query Usecase
		 * @param g
		 * @throws SQLException
		 */
		private void handleRangeQuery(Graphics g) throws SQLException {
			if (announcementMouseListner.getX() != -1) {
				if (!announcementMouseListner.isRightClick()) {
					rangeQueryPolygon.add(new Point(announcementMouseListner
							.getX(), announcementMouseListner.getY()));
					if (submitClicked) {
						submitClicked = false;
						rangeQueryPolygon = new ArrayList<Point>();
					}
				}

				for (int i = 0; i < rangeQueryPolygon.size(); i++) {
					drawPoint(g, (int) rangeQueryPolygon.get(i).getX(),
							(int) rangeQueryPolygon.get(i).getY());
					if (i < rangeQueryPolygon.size() - 1) {
						g.drawLine((int) rangeQueryPolygon.get(i).getX(),
								(int) rangeQueryPolygon.get(i).getY(),
								(int) rangeQueryPolygon.get(i + 1).getX(),
								(int) rangeQueryPolygon.get(i + 1).getY());
					}
				}

				if (announcementMouseListner.isRightClick()
						&& rangeQueryPolygon.size() != 0) {
					g.drawLine(
							(int) rangeQueryPolygon.get(0).getX(),
							(int) rangeQueryPolygon.get(0).getY(),
							(int) rangeQueryPolygon.get(
									rangeQueryPolygon.size() - 1).getX(),
							(int) rangeQueryPolygon.get(
									rangeQueryPolygon.size() - 1).getY());

					if (submitClicked) {
						submitClicked = false;
						String pString = getPolygonString(rangeQueryPolygon);
						if (chckbxAs.isSelected()) {
							String rangeASQuery = "SELECT radius, as_loc FROM Announcements WHERE ST_Intersects("
									+ pString + ", BUFFER(as_loc,radius));";
							drawAnnouncementSystem(g, rangeASQuery);
						}

						if (chckbxStudents.isSelected()) {
							String rangeStudentsQuery = "SELECT student_loc FROM Students WHERE ST_Intersects("
									+ pString + ", student_loc);";
							drawStudents(g, rangeStudentsQuery, Color.GREEN);
						}

						if (chckbxBuilding.isSelected()) {
							String rangeBuildingsQuery = "SELECT coordinates FROM Buildings WHERE ST_Intersects("
									+ pString + ", coordinates);";
							drawBuildings(g, rangeBuildingsQuery);
						}
					}
				}

			}
		}

		/**
		 * Converts the list of vertices to a Polygon string that can be used in a 
		 * SQL query
		 * @param points
		 * @return
		 */
		private String getPolygonString(ArrayList<Point> points) {
			String polyString = "GeomFromText('Polygon((";
			int i = 0;
			for (Point point : points) {
				if (i++ == 0)
					polyString = polyString + " " + point.x + " " + point.y;
				else
					polyString = polyString + " ," + point.x + " " + point.y;
			}
			polyString = polyString + " ," + points.get(0).x + " "
					+ points.get(0).y + "))')";
			return polyString;
		}

		/**
		 * Draws the buildings as required by the Point Query Usecase
		 * @param g
		 * @throws SQLException
		 */
		private void drawBuildingsPointQuery(Graphics g) throws SQLException {
			int clickedPointX = announcementMouseListner.getX();
			int clickedPointY = announcementMouseListner.getY();
			String pointString = "Point(" + clickedPointX + "," + clickedPointY
					+ "),";
			String closestBuildingsLoc = "select coordinates from Buildings WHERE ST_Intersects( Buffer("
					+ pointString + POINT_QUERY_RADIUS + "), coordinates); ";
			System.out.println("query :" + closestBuildingsLoc);
			ResultSet rs = executeSelectQuery(closestBuildingsLoc, connection);

			com.vividsolutions.jts.geom.Polygon minPoint = null;
			double minDistance = Integer.MAX_VALUE;
			HashSet<com.vividsolutions.jts.geom.Polygon> points = new HashSet<com.vividsolutions.jts.geom.Polygon>();

			while (rs.next()) {
				InputStream inputStream = rs.getBinaryStream("coordinates");
				try {
					com.vividsolutions.jts.geom.Polygon p = (com.vividsolutions.jts.geom.Polygon) getGeometryFromInputStream(inputStream);
					com.vividsolutions.jts.geom.Point cPoint = new com.vividsolutions.jts.geom.Point(
							new Coordinate(clickedPointX, clickedPointY),
							p.getPrecisionModel(), p.getSRID());

					if (p.distance(cPoint) < minDistance) {
						minDistance = p.distance(cPoint);
						minPoint = p;
					}
					points.add(p);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			for (com.vividsolutions.jts.geom.Polygon p : points) {
				if (minPoint.equals(p))
					drawBuildingPolygon(g, p, Color.YELLOW);
				else
					drawBuildingPolygon(g, p, Color.GREEN);
			}
		}

		/**
		 * Draws the students as required by the Point Query Usecase 
		 * @param g
		 * @throws SQLException
		 * @throws Exception
		 */
		private void drawStudentPointQuery(Graphics g) throws SQLException,
				Exception {
			int clickedPointX = announcementMouseListner.getX();
			int clickedPointY = announcementMouseListner.getY();
			String pointString = "Point(" + clickedPointX + "," + clickedPointY
					+ "),";
			String closestStudentsLoc = "select student_loc from students WHERE ST_Intersects( Buffer("
					+ pointString + POINT_QUERY_RADIUS + "), student_loc); ";
			System.out.println("query :" + closestStudentsLoc);
			ResultSet rs = executeSelectQuery(closestStudentsLoc, connection);

			com.vividsolutions.jts.geom.Point minPoint = null;
			double minDistance = Integer.MAX_VALUE;
			HashSet<com.vividsolutions.jts.geom.Point> points = new HashSet<com.vividsolutions.jts.geom.Point>();

			while (rs.next()) {

				InputStream inputStream = rs.getBinaryStream("student_loc");
				com.vividsolutions.jts.geom.Point p = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);

				com.vividsolutions.jts.geom.Point cPoint = new com.vividsolutions.jts.geom.Point(
						new Coordinate(clickedPointX, clickedPointY),
						p.getPrecisionModel(), p.getSRID());

				if (p.distance(cPoint) < minDistance) {
					minDistance = p.distance(cPoint);
					minPoint = p;
				}
				points.add(p);
			}

			for (com.vividsolutions.jts.geom.Point point : points) {
				if (minPoint.equals(point)) {
					int x = (int) point.getX();
					int y = (int) point.getY();
					g.setColor(Color.YELLOW);
					g.drawRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
					g.fillRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
				} else {
					int x = (int) point.getX();
					int y = (int) point.getY();
					g.setColor(Color.GREEN);
					g.drawRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
					g.fillRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
				}
			}
		}

		/**
		 * Draws the announcement systems as required by the Point Query Usecase
		 * @param g
		 * @throws SQLException
		 * @throws Exception
		 */
		private void drawASPointQuery(Graphics g) throws SQLException,
				Exception {
			String pointString = "Point(" + announcementMouseListner.getX()
					+ "," + announcementMouseListner.getY() + "),";
			String closestAnnouncementsLoc = "SELECT radius, as_loc FROM Announcements WHERE ST_Intersects( Buffer("
					+ pointString
					+ POINT_QUERY_RADIUS
					+ "), BUFFER(as_loc,radius)); ";
			System.out.println("query :" + closestAnnouncementsLoc);
			ResultSet rs = executeSelectQuery(closestAnnouncementsLoc,
					connection);

			com.vividsolutions.jts.geom.Point minPoint = null;
			double minDistance = Integer.MAX_VALUE;
			HashMap<com.vividsolutions.jts.geom.Point, Integer> points = new HashMap<com.vividsolutions.jts.geom.Point, Integer>();

			int clickedPointX = announcementMouseListner.getX();
			int clickedPointY = announcementMouseListner.getY();
			while (rs.next()) {

				int radius = rs.getInt("radius");
				InputStream inputStream = rs.getBinaryStream("as_loc");
				com.vividsolutions.jts.geom.Point p = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);

				com.vividsolutions.jts.geom.Point cPoint = new com.vividsolutions.jts.geom.Point(
						new Coordinate(clickedPointX, clickedPointY),
						p.getPrecisionModel(), p.getSRID());

				if (p.distance(cPoint) < minDistance) {
					minDistance = p.distance(cPoint);
					minPoint = p;
				}
				points.put(p, radius);
			}

			for (com.vividsolutions.jts.geom.Point point : points.keySet()) {
				if (minPoint.equals(point))
					drawAnnouncementCircle(g, points.get(point), point,
							Color.YELLOW);
				else
					drawAnnouncementCircle(g, points.get(point), point,
							Color.GREEN);

			}
		}

		/**
		 * Draws the clicked point for Point Query Usecase
		 * @param g
		 */
		private void drawClickedPoint(Graphics g) {
			drawPoint(g, announcementMouseListner.getX(),
					announcementMouseListner.getY());
			g.drawOval(announcementMouseListner.getX() - POINT_QUERY_RADIUS,
					announcementMouseListner.getY() - POINT_QUERY_RADIUS,
					2 * POINT_QUERY_RADIUS, 2 * POINT_QUERY_RADIUS);
		}

		/**
		 * Draws the clicked point as a red square dot
		 * @param g
		 * @param x
		 * @param y
		 */
		private void drawPoint(Graphics g, int x, int y) {
			g.setColor(Color.RED);
			g.drawRect(x - POINT_SQUARE_WIDTH / 2, y - POINT_SQUARE_WIDTH / 2,
					POINT_SQUARE_WIDTH, POINT_SQUARE_WIDTH);
			g.fillRect(x - POINT_SQUARE_WIDTH / 2, y - POINT_SQUARE_WIDTH / 2,
					POINT_SQUARE_WIDTH, POINT_SQUARE_WIDTH);
		}

		/**
		 * Draws announcement systems resulting from the selectAnnouncementsQuery
		 * @param g
		 * @param selectAnnouncementsQuery
		 * @throws SQLException
		 */
		private void drawAnnouncementSystem(Graphics g,
				String selectAnnouncementsQuery) throws SQLException {
			ResultSet rs = executeSelectQuery(selectAnnouncementsQuery,
					connection);
			while (rs.next()) {
				int radius = rs.getInt("radius");
				InputStream inputStream = rs.getBinaryStream("as_loc");
				try {
					com.vividsolutions.jts.geom.Point p = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);
					drawAnnouncementCircle(g, radius, p, Color.RED);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}

		/**
		 * Draws a given Announcement System 
		 * @param g
		 * @param radius
		 * @param p
		 * @param c
		 */
		private void drawAnnouncementCircle(Graphics g, int radius,
				com.vividsolutions.jts.geom.Point p, Color c) {
			int x;
			int y;
			g.setColor(c);
			x = (int) p.getX();
			y = (int) p.getY();
			g.drawRect(x - ANNOUNCEMENT_SQUARE_WIDTH/2, y - ANNOUNCEMENT_SQUARE_WIDTH/2, ANNOUNCEMENT_SQUARE_WIDTH, ANNOUNCEMENT_SQUARE_WIDTH);
			g.fillRect(x - ANNOUNCEMENT_SQUARE_WIDTH/2, y - ANNOUNCEMENT_SQUARE_WIDTH/2, ANNOUNCEMENT_SQUARE_WIDTH, ANNOUNCEMENT_SQUARE_WIDTH);
			g.drawOval(x - radius, y - radius, 2 * radius, 2 * radius);
		}

		/**
		 * Draws buildings resulting from the selectBuildingsQuery
		 * @param g
		 * @param selectBuildingsQuery
		 * @throws SQLException
		 */
		private void drawBuildings(Graphics g, String selectBuildingsQuery)
				throws SQLException {
			ResultSet rs = executeSelectQuery(selectBuildingsQuery, connection);
			while (rs.next()) {
				InputStream inputStream = rs.getBinaryStream("coordinates");
				try {
					com.vividsolutions.jts.geom.Polygon p = (com.vividsolutions.jts.geom.Polygon) getGeometryFromInputStream(inputStream);
					drawBuildingPolygon(g, p, Color.YELLOW);

				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		/**
		 * Draws a given polygon
		 * @param g
		 * @param p
		 * @param c
		 */
		private void drawBuildingPolygon(Graphics g,
				com.vividsolutions.jts.geom.Polygon p, Color c) {
			Coordinate[] polygonCoordinates = p.getCoordinates();
			int[] xArray = new int[polygonCoordinates.length];
			int[] yArray = new int[polygonCoordinates.length];
			for (int i = 0; i < polygonCoordinates.length; i++) {
				xArray[i] = (int) polygonCoordinates[i].x;
				yArray[i] = (int) polygonCoordinates[i].y;
			}
			Polygon polygon = new Polygon(xArray, yArray, xArray.length);
			g.setColor(c);
			g.drawPolygon(polygon);
		}

		/**
		 * Draws students resulting from selectStudentsQuery 
		 * @param g
		 * @param selectStudentsQuery
		 * @param c
		 * @throws SQLException
		 */
		private void drawStudents(Graphics g, String selectStudentsQuery,
				Color c) throws SQLException {
			int x;
			int y;
			ResultSet rs = executeSelectQuery(selectStudentsQuery, connection);
			while (rs.next()) {

				InputStream inputStream = rs.getBinaryStream("student_loc");
				try {
					com.vividsolutions.jts.geom.Point p = (com.vividsolutions.jts.geom.Point) getGeometryFromInputStream(inputStream);
					x = (int) p.getX();
					y = (int) p.getY();
					g.setColor(c);
					g.drawRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
					g.fillRect(x - STUDENT_SQUARE_WIDTH/2, y - STUDENT_SQUARE_WIDTH/2, STUDENT_SQUARE_WIDTH, STUDENT_SQUARE_WIDTH);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}
}
